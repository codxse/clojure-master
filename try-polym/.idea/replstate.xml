<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1485335341497">{:repl-history {:ide [], :local [&quot;(in-ns 'try-polym.multimethod)&quot; &quot;(animal-behavior {:animal-familly :cat\n                  :name \&quot;Garfield\&quot;})&quot; &quot;;; dispatch function, first will run this\n;; to decide what method to use\n(defmulti\n  animal-behavior\n  (fn [animal]\n    (get animal :animal-familly)))\n\n;; method, will return value\n(defmethod animal-behavior :cat\n  [animal]\n  {:name (get animal :name)\n   :familly (get animal :animal-familly)\n   :behavior \&quot;Meow!\&quot;})\n\n(defmethod animal-behavior :dog\n  [animal]\n  {:name (get animal :name)\n   :familly (get animal :animal-familly)\n   :behavior \&quot;Woof!\&quot;})\n\n(defmethod animal-behavior :cow\n  [animal]\n  {:name (get animal :name)\n   :familly (get animal :animal-familly)\n   :behavior \&quot;Mooh!\&quot;})&quot; &quot;(animal-behavior {:animal-familly :cat\n                  :name \&quot;Garfield\&quot;})\n(animal-behavior {:animal-familly :dog\n                  :name \&quot;Guffy\&quot;})\n(animal-behavior {:animal-familly :cow\n                  :name \&quot;Dancow\&quot;})&quot; &quot;(in-ns 'try-polym.core)&quot; &quot;(animal-behavior {:animal-familly :bird :name \&quot;Elang\&quot;})&quot; &quot;(refer 'try-polym.multimethod)&quot; &quot;(defmethod animal-behavior nil\n  [animal]\n  {:name (get animal :name :unknown)\n   :familly :unknown\n   :behavior \&quot;?\&quot;})&quot; &quot;(animal-behavior {})\n(animal-behavior {:name \&quot;Alien\&quot;})&quot; &quot;(animal-behavior)&quot; &quot;(ns-interns *ns*)&quot; &quot;(defmethod animal-behavior :default\n  [animal]\n  {:name (get animal :name)\n   :familly (get animal :animal-familly)\n   :behavior \&quot;~~~~~~~~~!\&quot;})&quot; &quot;(animal-behavior {:animal-familly :bird\n                  :name \&quot;Pigeon\&quot;})\n(animal-behavior {:animal-familly :frog\n                  :name \&quot;Kaeor\&quot;})&quot; &quot;(in-ns try-polym.record)&quot; &quot;(in-ns 'try-polym.record)&quot; &quot;(clojure.core/refer-clojure)&quot; &quot;(ns try-polym.record)\n\n(defrecord Animal [name animal-familly behavior])\n\n;; intensiate it!\n\n;; interloop java\n;; produce java object!\n(def cat (Animal. \&quot;Garfield\&quot; :cat \&quot;Meow!\&quot;))\n\n;; function factory\n(def dog (-&gt;Animal \&quot;Guffy\&quot; :dog \&quot;Woof!\&quot;))\n\n;; just like hash-map\n(def cow (map-&gt;Animal {:name \&quot;Dancow\&quot;\n                       :animal-familly :cow\n                       :behavior \&quot;Mooh!\&quot;}))&quot; &quot;(type cat)&quot; &quot;(ns try-polym.protocol\n  (:require [try-polym.record :refer [cat dog cow]])\n  (:import [try_polym.record Animal]))\n\n(defprotocol ICreature\n  (say-something [m])\n  (get-familly [m]))\n\n;; implement Creature\n(defrecord Animal [name animal-familly behavior]\n  ICreature\n  (say-something [m]\n    {:behavior (get m :behavior)})\n  (get-familly [m]\n    {:familly (get m :animal-familly)}))\n\n(say-something cat)\n(say-something dog)\n(say-something cow)\n\n(get-familly cat)\n(get-familly dog)\n(get-familly cow)\n\n&quot; &quot;(ns try-polym.record\n  (:require [try-polym.protocol :as p]))\n\n(defrecord Animal [name animal-familly behavior]\n  p/ICreature\n  (say-something [x] x)\n  (get-familly [x] x))\n\n;; intensiate it!\n\n;; interloop java\n;; produce java object!\n(def cat (Animal. \&quot;Garfield\&quot; :cat \&quot;Meow!\&quot;))\n\n;; function factory\n(def dog (-&gt;Animal \&quot;Guffy\&quot; :dog \&quot;Woof!\&quot;))\n\n;; just like hash-map\n(def cow (map-&gt;Animal {:name \&quot;Dancow\&quot;\n                       :animal-familly :cow\n                       :behavior \&quot;Mooh!\&quot;}))\n\n(say-something cat)&quot; &quot;(defrecord Animal [name animal-familly behavior]\n  p/ICreature\n  (p/say-something [x] x)\n  (p/get-familly [x] x))&quot; &quot;(say-something cat)&quot; &quot;(ns try-polym.record)\n\n(defrecord TreeNode [val l r])\n\n(defn xconj [t v]\n  (cond\n    (nil? t) (TreeNode. v nil nil)\n    (&lt; v (get t :val)) (TreeNode. (get t :val) (xconj (:l t) v) (get t :r))\n    :else (TreeNode. (get t :val) (get t :l) (xconj (get t :r) v))))\n\n(defn xseq [t]\n  (when t\n    (concat (xseq (get t :l)) [(get t :val) (xseq (get t :r))])))&quot; &quot;(def simple-tree (reduce xconj nil [3 5 2 4 6]))&quot; &quot;sample-tree&quot; &quot;simple-tree&quot; &quot;(xseq simple-tree)&quot;], :remote []}}</component>
</project>